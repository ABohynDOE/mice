% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parlmice.R
\name{parlmice}
\alias{parlmice}
\title{Wrapper function that runs MICE in parallel}
\usage{
parlmice(data, m = 5, n.core = NULL, n.imp.core = NULL,
  cluster.seed = NA, seed = NA, cl.type = "PSOCK", method,
  predictorMatrix, where, blocks, visitSequence, formulas, blots, post,
  defaultMethod, maxit, data.init, ...)
}
\arguments{
\item{data}{A data frame or matrix containing the incomplete data. Similar to 
the first argument of \code{\link{mice}}.}

\item{m}{The number of desired imputated datasets. By default $m=5$ as with \code{mice}}

\item{n.core}{A scalar indicating the number of cores that should be used.}

\item{n.imp.core}{A scalar indicating the number of imputations per core.}

\item{cluster.seed}{A scalar to be used as the seed value. It is recommended to put the 
seed value here and not outside this function, as otherwise the parallel processes
will be performed with separate, random seeds.}

\item{seed}{A scalar to be used as the seed value for the mice algorithm within 
each parallel stream. Please note that the imputations will be the same for all 
streams and, hence, this should be used if and only if \code{n.core = 1} and 
if it is desired to obtain the same output as under \code{mice}.}

\item{cl.type}{The cluster type. Default value is \code{"PSOCK"}. Posix machines (linux, Mac)
generally benefit from much faster cluster computation if \code{type} is set to \code{type = "FORK"}.}

\item{method}{Can be either a single string, or a vector of strings with
length \code{length(blocks)}, specifying the imputation method to be
used for each column in data. If specified as a single string, the same
method will be used for all blocks. The default imputation method (when no
argument is specified) depends on the measurement level of the target column,
as regulated by the \code{defaultMethod} argument. Columns that need
not be imputed have the empty method \code{""}. See details.}

\item{predictorMatrix}{A numeric matrix of \code{length(blocks)} rows 
and \code{ncol(data)} columns, containing 0/1 data specifying 
the set of predictors to be used for each target column.
Each row corresponds to a variable block, i.e., a set of variables 
to be imputed. A value of \code{1} means that the column
variable is used as a predictor for the target block (in the rows). 
By default, the \code{predictorMatrix} is a square matrix of \code{ncol(data)}
rows and columns with all 1's, except for the diagonal. 
Note: For two-level imputation models (which have \code{"2l"} in their names)
other codes (e.g, \code{2} or \code{-2}) are also allowed.}

\item{where}{A data frame or matrix with logicals of the same dimensions 
as \code{data} indicating where in the data the imputations should be 
created. The default, \code{where = is.na(data)}, specifies that the
missing data should be imputed. The \code{where} argument may be used to 
overimpute observed data, or to skip imputations for selected missing values.}

\item{blocks}{List of vectors with variable names per block. List elements 
may be named to identify blocks. Variables within a block are 
imputed by a multivariate imputation method
(see \code{method} argument). By default each variable is placed 
into its own block, which is effectively
fully conditional specification (FCS) by univariate models 
(variable-by-variable imputation). Only variables whose names appear in 
\code{blocks} are imputed. The relevant columns in the \code{where} 
matrix are set to \code{FALSE} of variables that are not block members. 
A variable may appear in multiple blocks. In that case, it is 
effectively re-imputed each time that it is visited.}

\item{visitSequence}{A vector of block names of arbitrary length, specifying the
sequence of blocks that are imputed during one iteration of the Gibbs 
sampler. A block is a collection of variables. All variables that are 
members of the same block are imputed 
when the block is visited. A variable that is a member of multiple blocks 
is re-imputed within the same iteration. 
The default \code{visitSequence = "roman"} visits the blocks (left to right)
in the order in which they appear in \code{blocks}. 
One may also use one of the following keywords: \code{"arabic"} 
(right to left), \code{"monotone"} (ordered low to high proportion 
of missing data) and \code{"revmonotone"} (reverse of monotone).}

\item{formulas}{A named list of formula's, or expressions that
can be converted into formula's by \code{as.formula}. List elements
correspond to blocks. The block to which the list element applies is 
identified by its name, so list names must correspond to block names.
The \code{formulas} argument is an alternative to the 
\code{predictorMatrix} argument that allows for more flexibility in 
specifying imputation models, e.g., for specifying interaction terms.}

\item{blots}{A named \code{list} of \code{alist}'s that can be used 
to pass down arguments to lower level imputation function. The entries
of element \code{blots[[blockname]]} are passed down to the function
called for block \code{blockname}.}

\item{post}{A vector of strings with length \code{ncol(data)} specifying
expressions as strings. Each string is parsed and 
executed within the \code{sampler()} function to post-process 
imputed values during the iterations. 
The default is a vector of empty strings, indicating no post-processing.}

\item{defaultMethod}{A vector of length 4 containing the default
imputation methods for 1) numeric data, 2) factor data with 2 levels, 3) 
factor data with > 2 unordered levels, and 4) factor data with > 2 
ordered levels. By default, the method uses 
\code{pmm}, predictive mean matching (numeric data) \code{logreg}, logistic
regression imputation (binary data, factor with 2 levels) \code{polyreg},
polytomous regression imputation for unordered categorical data (factor > 2
levels) \code{polr}, proportional odds model for (ordered, > 2 levels).}

\item{maxit}{A scalar giving the number of iterations. The default is 5.}

\item{data.init}{A data frame of the same size and type as \code{data},
without missing data, used to initialize imputations before the start of the
iterative process.  The default \code{NULL} implies that starting imputation
are created by a simple random draw from the data. Note that specification of
\code{data.init} will start all \code{m} Gibbs sampling streams from the same
imputation.}

\item{...}{Named arguments that are passed down to function \code{\link{mice}} or
\code{\link{makeCluster}}.}
}
\value{
A mids object as defined by \code{\link{mids-class}}
}
\description{
This is a wrapper function for \code{\link{mice}}, using multiple cores to 
execute \code{\link{mice}} in parallel. As a result, the imputation 
procedure can be sped up, which may be useful in general.
}
\details{
This function relies on package \code{\link{parallel}}, which is a base
package for R versions 2.14.0 and later. We have chosen to use parallel function 
\code{parLapply} to allow the use of \code{parlmice} on Mac, Linux and Windows
systems. For the same reason, we use the Parallel Socket Cluster (PSOCK) type by default.

On systems other than Windows, it can be hugely beneficial to change the cluster type to 
\code{FORK}, as it generally results in improved memory handling. When memory issues 
arise on a Windows system, we advise to store the multiply imputed datasets, 
clean the memory by using \code{\link{rm}} and \code{\link{gc}} and make another 
run using the same settings.

This wrapper function combines the output of \code{\link{parLapply}} with
function \code{\link{ibind}} in \code{\link{mice}}. A \code{mids} object is returned
and can be used for further analyses.

Note that if a seed value is desired, the seed should be entered to this function
with argument \code{seed}. Seed values outside the wrapper function (in an 
R-script or passed to \code{\link{mice}}) will not result to reproducible results. 
We refer to the manual of \code{\link{parallel}} for an explanation on this matter.
}
\examples{
# 150 imputations in dataset nhanes, performed by 3 cores  
\donttest{
imp1 <- parlmice(data = nhanes, n.core = 3, n.imp.core = 50)
# Making use of arguments in mice. 
imp2 <- parlmice(data = nhanes, method = "norm.nob", m = 100)
imp2$method
fit <- with(imp2, lm(bmi ~ hyp))
pool(fit)
}

}
\references{
Schouten, R. and Vink, G. (2017). parlmice: faster, paraleller, micer. 
\url{https://gerkovink.github.io/parlMICE/Vignette_parlMICE.html}

#'Van Buuren, S. (2018). 
\href{https://stefvanbuuren.name/fimd/parallel-computation.html}{\emph{Flexible Imputation of Missing Data. Second Edition.}}
Chapman & Hall/CRC. Boca Raton, FL.
}
\seealso{
\code{\link{parallel}}, \code{\link{parLapply}}, \code{\link{makeCluster}},
\code{\link{mice}}, \code{\link{mids-class}}
}
\author{
Gerko Vink, 2018, based on an earlier version by Rianne Schouten and Gerko Vink, 2017.
}
